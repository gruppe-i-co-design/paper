<!-- Copy and paste the converted output. -->

<!-----
NEW: Check the "Suppress top comment" option to remove this info from the output.

Conversion time: 12.798 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β29
* Wed Sep 16 2020 04:33:22 GMT-0700 (PDT)
* Source doc: codesign
* Tables are currently converted to HTML tables.
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!


WARNING:
You have 8 H1 headings. You may want to use the "H1 -> H2" option to demote all headings by one level.

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 1; ALERTS: 35.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>
<a href="#gdcalert17">alert17</a>
<a href="#gdcalert18">alert18</a>
<a href="#gdcalert19">alert19</a>
<a href="#gdcalert20">alert20</a>
<a href="#gdcalert21">alert21</a>
<a href="#gdcalert22">alert22</a>
<a href="#gdcalert23">alert23</a>
<a href="#gdcalert24">alert24</a>
<a href="#gdcalert25">alert25</a>
<a href="#gdcalert26">alert26</a>
<a href="#gdcalert27">alert27</a>
<a href="#gdcalert28">alert28</a>
<a href="#gdcalert29">alert29</a>
<a href="#gdcalert30">alert30</a>
<a href="#gdcalert31">alert31</a>
<a href="#gdcalert32">alert32</a>
<a href="#gdcalert33">alert33</a>
<a href="#gdcalert34">alert34</a>
<a href="#gdcalert35">alert35</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>


University of South-Eastern Norway, Kongsberg

Title of the paper

subtitle

(sorted by last name)

Anders Mæhlum Halvorsen  \
Rahmat Mozafari \
Ole Martin Ruud \
 Øzlem Tuzkaya


# Vision statement

Explore and implement three different sorting algorithms in software, hardware and as an integrated circuit (Intellectual Property (IP)), furthermore compare the different implementations with regards to efficiency, performance and flexibility (in particular hardware vs software tradeoffs).


# Storyboard


## Figure 1.1 (FSMD architecture for Selection sort)



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")



## Figure 1.2 (ASMD chart for Selection sort)



<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")



## Figure 1.3 (Result from hardware implementation of Selection sort)



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.png "image_tooltip")


The link above will navigate you to the directory where you can see simulation pictures in good quality. 

[Click here to see more pictures of simulation](https://drive.google.com/drive/u/0/folders/1ffAJxOUncl40DwOUA_8caFRPS7MD4N5g)


## Figure 1.4 (Result from software implementation of Selection sort)



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.png "image_tooltip")
 \
 \
Figure 1.3 (Result from hardware implementation of linear cell sort) 



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image5.png "image_tooltip")


The link above will navigate you to the directory where you can see simulation pictures in good quality. 

[Click here to see more pictures of simulation](https://drive.google.com/drive/u/0/folders/1FGTspiUHSEMUZeLDCJAXLv5cFgNYWshZ)


## Figure 2.1 (FSMD architecture of linear cell sort)

<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image6.png "image_tooltip")
 \
Figure 2.1.1 (FSMD architecture of single cell in linear cell sort) \


<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image7.png "image_tooltip")
 \



## Figure 2.1.2 (FSMD architecture of sort controller)

<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image8.png "image_tooltip")
Figure 2.2 (ASMD chart of linear cell sort) \


<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image9.png "image_tooltip")
 \



## Figure 2.2.1 (ASMD chart of single cell in linear cell sort)



<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image10.png "image_tooltip")
 \


Figure 2.2.2 (ASMD chart for sort controller) \


<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image11.png "image_tooltip")



# Introduction

(Something here)


# Methods

(The methods section is simply a record of what we did)

For our first sorting algorithm we decided to implement selection sort. The selection sort algorithm sorts an array by repeatedly finding the smallest element and swapping it with the first non-sorted element. If the first non-sorted element is the smallest, it will be “swapped” with itself. After swapping, we sort the remaining part of the array in similar fashion until the entire array is sorted. 

We implemented the algorithm in three different ways, Hardware, Software and as an Intellectual Property (IP). We challenged ourselves by starting with an ASMD chart before creating the FSMD architecture. We soon realised that this approach made the process more complex seeing that we were not sure what signals were needed; resulting in a change of strategy. Our new approach was to begin with the FSMD architecture and then creating the ASMD chart based on the FSMD architecture. After finding a satisfactory solution to the FSMD and ASMD, we implemented the hardware by taking in account the FSMD architecture. When implementing the Hardware solution, we wanted the design to be as reusable and adaptable as possible, consequently we created different design files for the multiplexers, comparator, ram, register and the control. As for the counter, we chose to create a generic counter file to be used for all of the counters. These files were then connected using a top-level file. To test our implementation we made a simulation file to verify that the waveforms behaved as expected.

After verifying that the hardware implementation worked as expected, we created a new project and started implementing the software in Vivado. Implementing the algorithm in software was quite simple as it is fairly straightforward to represent it using C. To verify that our implementation executed as expected, we used the terminal to print out an array before and after running the algorithm. 

The IP implementation, unlike the hardware and software implementation, was not as straightforward. We tried to implement it, but soon bumped into some problems with generating the IP block.

For our second algorithm we chose to implement a linear cell sorting algorithm based on the article linked below: [https://hackaday.com/2016/01/20/a-linear-time-sorting-algorithm-for-fpgas/](https://hackaday.com/2016/01/20/a-linear-time-sorting-algorithm-for-fpgas/)

The sorting algorithm uses cells / registers to sort the incoming data. It has only four rules: \




1. If a cell is empty, it will only be populated if the cell above is full.
2. If a cell is full, the cell data will be replaced if both the incoming data is less than the stored data, and the cell above is not pushing its data.
3. If the cell above the current cell is pushing out its stored data, then the current cell has to replace the current data with the cell data above.
4. If a cell is occupied and accepts new data either from the above cell or from the incoming data), it must push out the current data.

After learning from our previous mistake by starting with the ASMD chart instead of the FSMD architecture; we started by implementing the FSMD architecture for the cell first. After finding a satisfactory solution we moved on to the ASMD chart of the cell then made the top level FSMD architecture and the top level ASMD chart.

After going through our architectures / chars and verifying that it should work as expected, we started implementing the hardware implementation in Vivado. Similar to the previous sorting algorithm, the process was quite straightforward. We made sure to make the files as reusable as possible. Though, unlike the previous implementation, we made this implementation generic; meaning that we could define the length and size of the array in the top level file, instead of hard-coding the length inside the components.

 

 


# Results

In this section we will discuss the results we gathered throughout our research with regards to the different algorithms.  


## Selection Sort

Selection sort is the simplest sorting algorithm. In our implementation it will find the smallest element in the array and swap it with the element in the first position. then it will find the second smallest element and swap it with the element in the second position, and it will keep on doing this until the entire array is sorted. It has an O(n^2) time complexity and this is inefficient on large arrays. The input array divides into two subarrays, a sorted subarray of elements which is built up from the top to the bottom and the remaining unsorted elements occupy the rest of the array. 

The following example explains the necessary steps in our implementation of the selection sort algorithm. 



<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image12.png "image_tooltip")


Find the minimum element in RAM [0...4] and place it at the beginning.



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image13.png "image_tooltip")


Find the minimum element in RAM [1...4] and place it at beginning [1...4].



<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image14.png "image_tooltip")


Find the minimum element in RAM [2...4] and place it at beginning [2...4].



<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image15.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image15.png "image_tooltip")


Find the minimum element in RAM [3...4] and place it at beginning [3...4].



<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image16.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image16.png "image_tooltip")



### Hardware Implementation

In the hardware implementation we have created a generic counter and register which we want to reuse as much code as possible. The comparing counter is set to 1 as a default value and output of the ram will be the first element in the array when we run the program. We temporarily store this index value of this element in a register and increment the index counter to compare the elements to find the smallest element in the array. Again we temporarily store the index and the value of the smallest element in registers, then we swap those elements till the array is sorted. We have removed the ram from the design file into the test bench file which we wanted an external ram instead of an internal ram.



<p id="gdcalert17" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image17.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert18">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image17.png "image_tooltip")


File hierarchy for the hardware implementation.



<p id="gdcalert18" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image18.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert19">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image18.png "image_tooltip")


Synthesized report (Shows the power consumption) 



<p id="gdcalert19" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image19.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert20">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image19.png "image_tooltip")


Schematic of Elaborated design (external RAM) 



<p id="gdcalert20" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image20.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert21">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image20.png "image_tooltip")


Summary of synthesized report



<p id="gdcalert21" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image21.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert22">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image21.png "image_tooltip")


The picture below shows an unsorted array in the ram when the program starts. 



<p id="gdcalert22" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image22.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert23">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image22.png "image_tooltip")


swapping 77 with 01



<p id="gdcalert23" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image23.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert24">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image23.png "image_tooltip")


swapping the last elements



<p id="gdcalert24" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image24.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert25">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image24.png "image_tooltip")


Now array are sorted in the ram


### Software Implementation

The implementation of the algorithm in software was quick to write, and certainly inspired by the hardware implementation. To keep it consistent, we decided to stick with similar names for the different components (in particular index_counter and comparing_tindex_counter). This means that it should be easy to compare the implementations. We have tested the software implementation on Zybo board and worked perfectly.

Below is the code produced for the software implementation.


```
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

void sort(unsigned int *array, unsigned int length);
void print_array(unsigned int *array, unsigned int length);

const unsigned int DATA_LEN = 9;
unsigned int data[] = {14, 3, 8, 12, 5, 4, 5, 1, 77};

int main()
{
	init_platform();

	print("\n\rbefore: ");
	print_array(data, DATA_LEN);

	sort(data, DATA_LEN);

	print("\n\rafter : ");
	print_array(data, DATA_LEN);

	cleanup_platform();
	return 0;
}

void sort(unsigned int *array, unsigned int length) {

	for (int index_counter = 0; index_counter < length; ++index_counter) {
		// Set index_counter element as smallest found element
		unsigned int smallest_index = index_counter;
		unsigned int smallest_value = array[index_counter];
		
		// Compare smallest element with rest of array and keep the smallest element
		// found (including index)
		for (int comparing_index_counter = index_counter + 1; comparing_index_counter < length; ++comparing_index_counter) {
			if (array[comparing_index_counter] < smallest_value) {
				smallest_value = array[comparing_index_counter];
				smallest_index = comparing_index_counter;
			}
		}

		// Swap first and smallest elements
		unsigned int temp = array[index_counter];
		array[index_counter] = smallest_value;
		array[smallest_index] = temp;
	}
}

void print_array(unsigned int *array, unsigned int length) {
	for (int i = 0; i < length; ++i) {
		char buf[10];
		sprintf(buf, "%2d%s", array[i], i + 1 == length ? "" : ", ");
		print(buf);
	}
}
```



### IP Implementation

In IP implementation we followed the “Vivado Quick Start Tutorial” and made some necessary changes in some files. We declared some output ports and port mapped those in the  “selection_sort_IP_v1_0.vhd”. Next, we made a component declaration and created some signals for inputs and outputs in the “selection_sort_IP_v1_0_S00_AXI.vhd” file. The VHDL description files which were created for the hardware implementation of selection sort algorithm we copied those files into IP directory and created a new AXI4 Peripheral for IP. 

After this we created a new block design to integrate our IP, added and customized the “ZYNQ7 Processing System”. Our next step was that we added “selection_sort_IP_v1.0” into our design and created HDL Wrapper. Further we added the sort controller and the block memory IP blocks into our design. The block memory generator is the previously explained external RAM, while the sort controller enables us to inspect the memory after it has be sorted (simply enabling our software running on the ZYNQ prossessor to read the memory through AXI). 



<p id="gdcalert25" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image25.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert26">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image25.png "image_tooltip")


The IP block diagram including the selection sort block, sort controller and memory



<p id="gdcalert26" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image26.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert27">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image26.png "image_tooltip")


Synthesized power consumption report  



<p id="gdcalert27" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image27.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert28">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image27.png "image_tooltip")


<p id="gdcalert28" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image28.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert29">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image28.png "image_tooltip")


Schematic of Elaborated design ( we need to update this two images)

Finally, after putting together the different IP blocks, we generated a bitstream to see if there was any error and also we needed to export hardware design  to the Vitis IDE. In Vitis IDE we first created a project platform for the (XSA) file extension which exported from the Vivado and generated multiple domains. We built the project and created a new application project for the software application to test our IP implementation.

To communicate with the sort controller, enabling us to read the sorted memory, we need to talk through the AXI interface. This is done using some special functions provided by the platform. By reading slave register 2 of the sort controller, we can tell if the sorting is done, as the first bit represents the sort_done variable. Further by then repeatedly reading slave register 1, we will get the contents of the memory block, as the sort controller continuously updates the RAM address and reads the data into the slave register. 


```
#include "xparameters.h"
#include "xuartps_hw.h"

int main(){
	xil_printf("Start selection sort\n\n\r");

	xil_printf("Sorting");
	u32 slave_reg_2;
	do {
		slave_reg_2 = Xil_In32(XPAR_SORT_CONTROLLER_0_S00_AXI_BASEADDR + 8);
		xil_printf(".");
	} while ((slave_reg_2 & 0x1) == 0);
	xil_printf("\n\r");

	xil_printf("Printing\n\r");
	u32 slave_reg_1;
	do {
		slave_reg_2 = Xil_In32(XPAR_SORT_CONTROLLER_0_S00_AXI_BASEADDR + 8);
		slave_reg_1 = Xil_In32(XPAR_SORT_CONTROLLER_0_S00_AXI_BASEADDR + 4);
		xil_printf("%lx ", slave_reg_1);
	} while ((slave_reg_2 & 0x1) == 1);

	return 0;
}
```



## Linear cell sort 

Linear cell sort receives data once per clock cycle and sorts the data while it's being clocked in serially, that's why this algorithm is called linear cell sort. Hence it can sort an array in O(N) time complexity. After we have clocked in our data the array will be sorted immediately and should be ready to clocked out. The solution provides the sorting in parallel. 

Since we decided to make the algorithm generic it will let you decide the size and length of the array. As you can see from figure 2.1 (Top FSMD architecture), the amount of cells will be the same as array size. New incoming data will be placed to the cell from top to bottom with increasing size. So when all cells are empty the first element will automatically take the first place. Second incoming data will be compared with the first element, if it's smaller than the first element then the first element will be moved to the second cell and the new data will be placed to the first cell. Third incoming data will be compared with the other cells, if the incoming data is smaller than the first cell then we have a full and pushed.The data in the first cell will be pushed to the second cell and the data in the second cell will be pushed to third cell and the new incoming data will be placed to the first cell. The sorting algorithm will continue like this until the whole array is sorted.  

Hardware implementation of linear cell sort

The implementation of linear cell sort algorithms was more complicated than Selection sort.  We needed to draw multi FSMD and ASMD charts to implement this in hardware. Since this algorithm uses cells and to implement this in hardware we needed to draw a FSMD and ASMD chart for this to control each cell. Then we draw another FSMD and ASMD chart to control all cells and plus other components. In our implementation we neither use RAM or ROM.



<p id="gdcalert29" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image29.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert30">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image29.png "image_tooltip")


File hierarchy of design sources



<p id="gdcalert30" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image30.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert31">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image30.png "image_tooltip")


Schematic of elaborated design



<p id="gdcalert31" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image31.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert32">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image31.png "image_tooltip")


Synthesized report of On-Chip Power

 

<p id="gdcalert32" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image32.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert33">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image32.png "image_tooltip")


Utilization synthesized report


# 

<p id="gdcalert33" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image33.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert34">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image33.png "image_tooltip")


<p id="gdcalert34" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image34.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert35">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image34.png "image_tooltip")


If the pictures are unreadable so please,  see the appendix for links and it will navigate you to a directory where you can see pictures in good quality. 


## Software implementation

Since this algorithm is parallel by nature, there are some tradeoffs to be made when implementing it in software. As we only have a single core to work with, we have chosen to simply transform it into a sequential algorithm. This means that instead of O(N) time complexity, it will be O(N²) time complexity (as we have to iterate through every cell on every insertion). As such, we chose to handle the algorithm by having a ROM and a pointer to the “incoming” input, and Instead of using cells, we chose to use an array to be simulated as multiple cells.

The implementation was tested on the Zybo board, and it returned the expected outcome.



<p id="gdcalert35" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image35.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert36">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image35.png "image_tooltip")


Result from inspecting the serial monitor


```
#include "xparameters.h"
#include "xuartps_hw.h"

#include <stdio.h>

#define DATA_LENGTH 8

void shiftAndReplace(unsigned int fromPosition, unsigned int newValue);
void print_array(unsigned int *array, unsigned int length);
void sort(unsigned int *array, unsigned int length);

unsigned int data[DATA_LENGTH] = {7, 4, 2, 12, 4, 6, 4, 100};
unsigned int sorted_data[DATA_LENGTH] = {0, 0, 0, 0, 0, 0, 0, 0};

int main() {
    //init_platform();

    // Sorts the array "data", that is in this case used as a ROM
    sort(data, DATA_LENGTH);

    // Prints out the sorted array
    print_array(sorted_data, DATA_LENGTH);

    //cleanup_platform();
    return 0;
}

void sort(unsigned int *array, unsigned int length) {
    for (int i = 0; i < length; i++){
   	 // The contents of this loop is done in parallel in the hardware implementation, however we do it sequentially to simplify the software implementation

   	 if((i == 0)){
   		 sorted_data[i] = array[i];
   	 } else {
   		 for(int j = 0; j < length; j++){
   			 // If true, then move every element in the array to the right
   			 if(sorted_data[j] > array[i]){
   				 // Logic for moving and replacing here
   				 shiftAndReplace(j, array[i]);
   				 break;
   			 } else if (sorted_data[j] == '\0' && sorted_data[j-1] != '\0') {
   				 // Else if the element is bigger, we place it in the empty spot
   				 sorted_data[j] = array[i];
   				 break;
   			 }
   		 }
   	 }
    }
}

void shiftAndReplace(unsigned int fromPosition, unsigned int newValue){
    for(int i = DATA_LENGTH - 1; i > fromPosition; i--){
   	 sorted_data[i] = sorted_data[i-1];
    }
    sorted_data[fromPosition] = newValue;
}

void print_array(unsigned int *array, unsigned int length) {
    printf("Sorted Array: ");
    for (int i = 0; i < length; ++i) {
   	 char buffer[10];
   	 sprintf(buffer, "%2d%s", array[i], i + 1 == length ? "" : ", ");
   	 printf(buffer);
    }
    printf("\n");
}
```



# Appendix 

Click to the links and it will navigate you to the files. 

[VHDL code for the hardware implementation for  Selection sort](https://drive.google.com/drive/u/0/folders/11M6L_d4wSiqDomZrZS4rpU_q2PV-XrMc)

[Software implementation code  for Selection sort](https://drive.google.com/drive/u/0/folders/1VvU5pwuXmeHH2R9Az5_1_RrhUMAYxoEJ)

[IP implementation code for the Selection sort](https://drive.google.com/drive/u/0/folders/1E7tOzUvZYuaMUpTJExdSYgssHIWZG2uI)

[VHDL code for the hardware implementation for the linear cell sort](https://drive.google.com/drive/u/0/folders/1FGTspiUHSEMUZeLDCJAXLv5cFgNYWshZ)

[Software implementation code  for the linear cell sort](https://drive.google.com/drive/u/0/folders/1RMSNPuhLWe77ts9YGAc6EpMlsd6bUva0)

All FSMD and ASMD charts 

[ASMD and FSMD charts](https://app.lucidchart.com/invitations/accept/4f18b690-f5b3-4d20-a44a-b7fe59f9f84e)  (To navigate between diagrams click on page at the bottom of file)


# Links

[https://hackaday.com/2016/01/20/a-linear-time-sorting-algorithm-for-fpgas/](https://hackaday.com/2016/01/20/a-linear-time-sorting-algorithm-for-fpgas/)

[https://en.wikipedia.org/wiki/Batcher_odd%E2%80%93even_mergesort](https://en.wikipedia.org/wiki/Batcher_odd%E2%80%93even_mergesort)
